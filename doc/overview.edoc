%%==============================================================================
%% Copyright 2010 Erlang Solutions Ltd.
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%% http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%==============================================================================

@copyright 2010 Erlang Solutions Ltd.
@title unsplit - A framework for resolving Mnesia netsplits

@doc

### Changes over the original code:

- Merged pull request related to `all_remote_keys' strategy. Identical to `all_keys' but will fetch all keys from remote node and works on an union of the keys.
- Improve `all_remote_keys' strategy merge performance.
- Add support to set the unsplit strategy per table using `unsplit_strategy' property.
- Use `logger' for logging messages.
- Fix crash because of discrepancy in the number of params in reporting function.
- [Merge pull request](https://github.com/esl/unsplit/pull/2): `unsplit_server' attempts to stitch together nodes before they would become reconnected.
- Fix rebar3 compiling and update all deps.
- Fix docs generation via rebar3 edoc.
- Fix all common tests.
- Reformat the code to enhance readability.

### What is unsplit ?

Unsplit is a framework for registering merge functions that will be called any time mnesia tries to heal from netsplits.

The default behaviour of mnesia is not to attempt automatic merge after a **partitioned network** event. It detects and reports  the condition, but
leaves it up to the user to resolve the problem.

Mnesia itself offers a few remedies: restart from backup, or elect to unconditionally reload tables from one or more nodes - in both cases
data loss is very likely.

Unsplit starts a subscription on the **partitioned network** event, and forces Mnesia to merge the "islands" that have been separated. It inserts
itself into the schema merge transaction, claiming table locks on all affected tables. It then runs user-provided merge callbacks for each
table, fetching data from one side, comparing the objects, and writing back the data that should be kept.

### Writing an Unsplit method

Unsplit methods are table-specific, although a default method can be set using the `unsplit' application environment variable

<pre lang="erlang">
{default_method, {Module, Function, ExtraArgs}}
</pre>

The given method is called with the following arguments:

<pre lang="erlang">
apply(Module, Function, [init, Table, Attributes | ExtraArgs]) -> ret()
</pre>

to set up the merge. Then, data will be fetched using a given fetch strategy, and the fetched data will be handed to the merge function as:

<pre lang="erlang">
apply(Module, Function, [data(), state()]) -> ret()
</pre>

The return value, `ret()' is defined as:

<pre lang="erlang">
ret() :: stop
       | {ok, state()}
       | {ok, actions(), state()}
       | {ok, actions(), strategy(), state()}

actions() :: [action()]

action() :: {write, Objects} | {delete, Objects}

strategy() :: all_keys | {ModS, FunS}
</pre>

If a custom fetch strategy function is given, it will be called as:

<pre lang="erlang">
apply(ModS, FunS, [Table, RemoteNode, state()]) -> {ok, data(), state()}
</pre>

Note that `state()' is whatever the merge function creates. The unsplit framework treats it as an opaque object, but the fetch function needs to
do the same, or be aware of its definition.

The format of `data()' can be anything that the merge function accepts, but if the built-in strategy `all_keys' is used, it will have the format:

<pre lang="erlang">
data() :: [{[object()], [object()]}]
</pre>

where each 2-tuple represents the data matching a given key on each side of the split. Thus, `[{[{mytab, 1, a}], []}]' would mean that the
object `{mytab, 1, a}' only exists on the side where the merge process is running, but is not found on the other side. `[{[{mytab,2,a}], [{mytab,2,b}]}]'
would mean that conflicting versions of the object `{mytab,2}' were found.

@end
